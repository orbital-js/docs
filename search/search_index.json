{
    "docs": [
        {
            "location": "/", 
            "text": "Home\n\n\nIntroduction\n\n\nOrbital is a command-line interface (\nCLI\n) framework used to build scalable command-line programs. Orbital is designed to run on \nNode.JS\n, and uses \nTypeScript\n for type checking and \nmetadata reflection\n. Orbital projects work best when used in conjunction with \nNPM\n, and are distributed as \nNPM\n packages.\n\n\nPhilosophy\n\n\nWhen we began contributing to the Nest CLI project, we found that the framework that was initially used was confusing and non-standard. Upon analyzing other CLI projects, we found that many of them also did not have standards, and were using strange combinations of some of the existing frameworks.\n\n\nWe created Orbital to be the most feature-rich and standardized, yet beautifully simple CLI framework currently available. Out of the box, we've designed Orbital to be the best solution to building your next CLI project.\n\n\nFeatures\n\n\n\n\nBuilt with TypeScript for static type-checking\n\n\nRun-time type checks and parameter casting\n\n\nRun-time validation\n\n\nPerformance-optimized \"production mode\"\n\n\nAngular-based dependency injection\n\n\nBeautiful help generation\n\n\n\n\nInstallation\n\n\nStart a project with \nTypeScript\n:\n\n\ngit clone https://github.com/orbital-js/starter.git your-project-name\n\ncd\n your-project-name\nnpm install\nnpm start\n\n\n\n\nStart a new project from scratch with \nNPM\n:\n\n\nnpm install --save @orbital/core\n\n\n\n\nPeople\n\n\nOrbital was created by \nWilson Hobbs\n and \nAnge Picard\n in 2018.\n\n\nContributors", 
            "title": "Home"
        }, 
        {
            "location": "/#home", 
            "text": "", 
            "title": "Home"
        }, 
        {
            "location": "/#introduction", 
            "text": "Orbital is a command-line interface ( CLI ) framework used to build scalable command-line programs. Orbital is designed to run on  Node.JS , and uses  TypeScript  for type checking and  metadata reflection . Orbital projects work best when used in conjunction with  NPM , and are distributed as  NPM  packages.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#philosophy", 
            "text": "When we began contributing to the Nest CLI project, we found that the framework that was initially used was confusing and non-standard. Upon analyzing other CLI projects, we found that many of them also did not have standards, and were using strange combinations of some of the existing frameworks.  We created Orbital to be the most feature-rich and standardized, yet beautifully simple CLI framework currently available. Out of the box, we've designed Orbital to be the best solution to building your next CLI project.", 
            "title": "Philosophy"
        }, 
        {
            "location": "/#features", 
            "text": "Built with TypeScript for static type-checking  Run-time type checks and parameter casting  Run-time validation  Performance-optimized \"production mode\"  Angular-based dependency injection  Beautiful help generation", 
            "title": "Features"
        }, 
        {
            "location": "/#installation", 
            "text": "Start a project with  TypeScript :  git clone https://github.com/orbital-js/starter.git your-project-name cd  your-project-name\nnpm install\nnpm start  Start a new project from scratch with  NPM :  npm install --save @orbital/core", 
            "title": "Installation"
        }, 
        {
            "location": "/#people", 
            "text": "Orbital was created by  Wilson Hobbs  and  Ange Picard  in 2018.", 
            "title": "People"
        }, 
        {
            "location": "/#contributors", 
            "text": "", 
            "title": "Contributors"
        }, 
        {
            "location": "/guide/introduction/", 
            "text": "Introduction\n\n\nFirst Steps\n\n\nThe Guide will lead you through building your first Orbital CLI, and will go over the fundamentals of the Orbital framework.\n\n\nLanguage\n\n\nOrbital is built with \nTypeScript\n, and we recommend developers do the same. Orbital has not been rigorously tested with pure JavaScript, and the documentation will have exclusively TypeScript examples.\n\n\nPrerequisites\n\n\nPlease make sure that \nNode.JS\n (\n=6.0.0) is installed on your operating system. We recommend Node 8 or later. You will also need TypeScript v2.7 or later, and NPM v3 or later.\n\n\nSetup\n\n\nSetting up a new project is quite simple with the \nstarter\n. You can clone the repo and get started with these commands:\n\n\n1\n2\n3\ngit clone https://github.com/orbital-js/starter project-name\n\ncd\n project-name\nnpm install\n\n\n\n\n\n\nThe \nproject\n directory will contain several core files inside \nsrc\n directory.\n\n\nsrc\n\u2514\u2500\u2500 main.ts\n\u2514\u2500\u2500 cli.ts\n\u2514\u2500\u2500 commands\n    \u2514\u2500\u2500 hello.command.ts\n\n\n\n\nThese files each serve an important and unique purpose, outlined in the table below.\n\n\n\n\n\n\n\n\nFile\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmain.ts\n\n\nThe entry point to your CLI. Provides bootstrapping logic to render the CLI.\n\n\n\n\n\n\ncli.ts\n\n\nDefines the primary CLI instance of the application.\n\n\n\n\n\n\ncommands/hello.command.ts\n\n\nA single executable command with business logic for when the command is triggered.\n\n\n\n\n\n\n\n\nThe \nmain.ts\n includes an single function, which responsibility is to \nbootstrap\n our application:\n\n\n1\n2\n3\n4\n5\nimport\n \n{\n \nOrbitalFactory\n \n}\n \nfrom\n \n@orbital/core\n;\n\n\nimport\n \n{\n \nMyCLI\n \n}\n \nfrom\n \n./cli\n;\n\n\n\nOrbitalFactory\n.\nbootstrap\n(\nMyCLI\n)\n\n    \n.\nexecute\n(\nprocess\n.\nargv\n);\n\n\n\n\n\n\n\nTo instantiate the application, the \nbootstrap\n method handles all of the command resolution and injection. The \nexecute\n method accepts an array of strings, typically \nprocess.argv\n, as the command line input. It can be useful, however, to substitute in other arrays, particularly during testing. We will cover this in a later guide.\n\n\nRunning Your CLI\n\n\nOnce you've downloaded and installed the starter, you can run this command to make sure that everything is configured properly.\n\n\n$ npm start -- hello\nWelcome to Orbital CLI!\n\n\n\n\nIf everything worked correctly, you'll see \"Welcome to Orbital CLI!\" output below the command.", 
            "title": "Introduction"
        }, 
        {
            "location": "/guide/introduction/#introduction", 
            "text": "", 
            "title": "Introduction"
        }, 
        {
            "location": "/guide/introduction/#first-steps", 
            "text": "The Guide will lead you through building your first Orbital CLI, and will go over the fundamentals of the Orbital framework.", 
            "title": "First Steps"
        }, 
        {
            "location": "/guide/introduction/#language", 
            "text": "Orbital is built with  TypeScript , and we recommend developers do the same. Orbital has not been rigorously tested with pure JavaScript, and the documentation will have exclusively TypeScript examples.", 
            "title": "Language"
        }, 
        {
            "location": "/guide/introduction/#prerequisites", 
            "text": "Please make sure that  Node.JS  ( =6.0.0) is installed on your operating system. We recommend Node 8 or later. You will also need TypeScript v2.7 or later, and NPM v3 or later.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/guide/introduction/#setup", 
            "text": "Setting up a new project is quite simple with the  starter . You can clone the repo and get started with these commands:  1\n2\n3 git clone https://github.com/orbital-js/starter project-name cd  project-name\nnpm install   The  project  directory will contain several core files inside  src  directory.  src\n\u2514\u2500\u2500 main.ts\n\u2514\u2500\u2500 cli.ts\n\u2514\u2500\u2500 commands\n    \u2514\u2500\u2500 hello.command.ts  These files each serve an important and unique purpose, outlined in the table below.     File  Description      main.ts  The entry point to your CLI. Provides bootstrapping logic to render the CLI.    cli.ts  Defines the primary CLI instance of the application.    commands/hello.command.ts  A single executable command with business logic for when the command is triggered.     The  main.ts  includes an single function, which responsibility is to  bootstrap  our application:  1\n2\n3\n4\n5 import   {   OrbitalFactory   }   from   @orbital/core ;  import   {   MyCLI   }   from   ./cli ;  OrbitalFactory . bootstrap ( MyCLI ) \n     . execute ( process . argv );    To instantiate the application, the  bootstrap  method handles all of the command resolution and injection. The  execute  method accepts an array of strings, typically  process.argv , as the command line input. It can be useful, however, to substitute in other arrays, particularly during testing. We will cover this in a later guide.", 
            "title": "Setup"
        }, 
        {
            "location": "/guide/introduction/#running-your-cli", 
            "text": "Once you've downloaded and installed the starter, you can run this command to make sure that everything is configured properly.  $ npm start -- hello\nWelcome to Orbital CLI!  If everything worked correctly, you'll see \"Welcome to Orbital CLI!\" output below the command.", 
            "title": "Running Your CLI"
        }, 
        {
            "location": "/guide/cli/", 
            "text": "CLI\n\n\nThe CLI decorator is the primary consolidator of our CLI. We use the CLI decorator to store metadata about our CLI, as well as contain and resolve commands. In the future, the CLI decorator will be used to deal with dependency injection.\n\n\nDecorators are a TypeScript feature that make it easier for Orbital developers to build their applications. Rather than dealing with ugly, inconsistent objects, Orbital allows you to use decorators to directly modify the class to which it is applied. Check out these comparisons:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n// Fun, pretty, and correct\n\n\nimport\n \n{\n \nCLI\n \n}\n \nfrom\n \n@orbital/core\n;\n\n\n\n@CLI\n({\n\n    \nname\n:\n \nmy-cli\n,\n\n    \ncommands\n:\n \n[\n\n        \n//...\n\n    \n],\n\n    \nversion\n:\n \n1.0.0\n\n\n})\n\n\nexport\n \nclass\n \nMyCLI\n \n{\n \n}\n\n\n\n\n\n\n\nNow, compare that beautiful example to this complex, non-immutable object:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n// WRONG!\n\n\nimport\n \n{\n \nCLI\n \n}\n \nfrom\n \n@orbital/core\n;\n\n\n\nexport\n \nconst\n \nmyCli\n: \nCLI\n \n=\n \n{\n\n    \nname\n:\n \nmy-cli\n,\n\n    \ncommands\n:\n \n[\n\n        \n// ...\n\n    \n],\n\n    \nversion\n:\n \n1.0.0\n\n\n}\n\n\n\n\n\n\n\nObviously, this is a little bit of an opinionated decision, but once you move past this syntax, Orbital is not very complex to learn.", 
            "title": "CLI"
        }, 
        {
            "location": "/guide/cli/#cli", 
            "text": "The CLI decorator is the primary consolidator of our CLI. We use the CLI decorator to store metadata about our CLI, as well as contain and resolve commands. In the future, the CLI decorator will be used to deal with dependency injection.  Decorators are a TypeScript feature that make it easier for Orbital developers to build their applications. Rather than dealing with ugly, inconsistent objects, Orbital allows you to use decorators to directly modify the class to which it is applied. Check out these comparisons:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 // Fun, pretty, and correct  import   {   CLI   }   from   @orbital/core ;  @CLI ({ \n     name :   my-cli , \n     commands :   [ \n         //... \n     ], \n     version :   1.0.0  })  export   class   MyCLI   {   }    Now, compare that beautiful example to this complex, non-immutable object:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 // WRONG!  import   {   CLI   }   from   @orbital/core ;  export   const   myCli :  CLI   =   { \n     name :   my-cli , \n     commands :   [ \n         // ... \n     ], \n     version :   1.0.0  }    Obviously, this is a little bit of an opinionated decision, but once you move past this syntax, Orbital is not very complex to learn.", 
            "title": "CLI"
        }, 
        {
            "location": "/guide/components/", 
            "text": "Creating a Component\n\n\nAlmost everything is a component \u2013 Service, Repository, Factory, Helper [...] and they can be \ninjected\n into controllers or to other components through \nconstructor\n.\n\n\n\n\nIn the previous chapter, we have built a simple \nCatsController\n.\n\n\nThe controllers should only handle HTTP requests and delegate more complex tasks to the \ncomponents\n. The components are a plain TypeScript classes with \n@Component()\n decorator.\n\n\n\n\nHint\n\n\nSince Nest enables the possibility to design, organize the dependencies in more OO-way, we strongly recommend to follow the \nSOLID\n principles.\n\n\n\n\nLet's create a \nCatsService\n component:\n\n\nTypeScript\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\nimport\n \n{\n \nComponent\n \n}\n \nfrom\n \n@nestjs/common\n;\n\n\nimport\n \n{\n \nCat\n \n}\n \nfrom\n \n./interfaces/cat.interface\n;\n\n\n\n@Component\n()\n\n\nexport\n \nclass\n \nCatsService\n \n{\n\n    \nprivate\n \nreadonly\n \ncats\n: \nCat\n[]\n \n=\n \n[];\n\n\n    \ncreate\n(\ncat\n: \nCat\n)\n \n{\n\n        \nthis\n.\ncats\n.\npush\n(\ncat\n);\n\n    \n}\n\n\n    \nfindAll\n()\n:\n \nCat\n[]\n \n{\n\n        \nreturn\n \nthis\n.\ncats\n;\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nJavaScript\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\nimport\n \n{\n \nComponent\n \n}\n \nfrom\n \n@nestjs/common\n;\n\n\n\n@\nComponent\n()\n\n\nexport\n \nclass\n \nCatsService\n \n{\n\n    \nconstructor\n()\n \n{\n\n        \nthis\n.\ncats\n \n=\n \n[];\n\n    \n}\n\n\n    \ncreate\n(\ncat\n)\n \n{\n\n        \nthis\n.\ncats\n.\npush\n(\ncat\n);\n\n    \n}\n\n\n    \nfindAll\n()\n \n{\n\n        \nreturn\n \nthis\n.\ncats\n;\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nThere's nothing specifically about components. Here's a \nCatsService\n, a basic class with one property and two methods. The only difference is that it has the \n@Component()\n decorator. The \n@Component()\n attaches the metadata, thereby Nest knows that this class is a Nest component.\n\n\n\n\nNote\n\n\nThere's a \nCat\n interface here. I didn't mention it because the schema is exactly same as in the \nCreateCatDto\n class which we have created in the previous chapter.\n\n\n\n\nDependency Injection\n\n\nSince we have the service class already done, let's use it inside the \nCatsController\n:\n\n\nTypeScript\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nimport\n \n{\n \nController\n,\n \nGet\n,\n \nPost\n,\n \nBody\n \n}\n \nfrom\n \n@nestjs/common\n;\n\n\nimport\n \n{\n \nCreateCatDto\n \n}\n \nfrom\n \n./dto/create-cat.dto\n;\n\n\nimport\n \n{\n \nCatsService\n \n}\n \nfrom\n \n./cats.service\n;\n\n\nimport\n \n{\n \nCat\n \n}\n \nfrom\n \n./interfaces/cat.interface\n;\n\n\n\n@Controller\n(\ncats\n)\n\n\nexport\n \nclass\n \nCatsController\n \n{\n\n    \nconstructor\n(\nprivate\n \nreadonly\n \ncatsService\n: \nCatsService\n)\n \n{}\n\n\n    \n@Post\n()\n\n    \nasync\n \ncreate\n(\n@Body\n()\n \ncreateCatDto\n: \nCreateCatDto\n)\n \n{\n\n        \nthis\n.\ncatsService\n.\ncreate\n(\ncreateCatDto\n);\n\n    \n}\n\n\n    \n@Get\n()\n\n    \nasync\n \nfindAll\n()\n:\n \nPromise\nCat\n[]\n \n{\n\n        \nreturn\n \nthis\n.\ncatsService\n.\nfindAll\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nJavaScript\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nimport\n \n{\n \nController\n,\n \nGet\n,\n \nPost\n,\n \nBody\n,\n \nBind\n,\n \nDependencies\n \n}\n \nfrom\n \n@nestjs/common\n;\n\n\nimport\n \n{\n \nCatsService\n \n}\n \nfrom\n \n./cats.service\n;\n\n\n\n@\nController\n(\ncats\n)\n\n\n@\nDependencies\n(\nCatsService\n)\n\n\nexport\n \nclass\n \nCatsController\n \n{\n\n    \nconstructor\n(\ncatsService\n)\n \n{\n\n        \nthis\n.\ncatsService\n \n=\n \ncatsService\n;\n\n    \n}\n\n\n    \n@\nPost\n()\n\n    \n@\nBind\n(\nBody\n())\n\n    \nasync\n \ncreate\n(\ncreateCatDto\n)\n \n{\n\n        \nthis\n.\ncatsService\n.\ncreate\n(\ncreateCatDto\n);\n\n    \n}\n\n\n    \n@\nGet\n()\n\n    \nasync\n \nfindAll\n()\n \n{\n\n        \nreturn\n \nthis\n.\ncatsService\n.\nfindAll\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nThe \nCatsService\n is injected through the class constructor. Don't be afraid of the \nprivate readonly\n shortened syntax. It means that we've created and initialized the \ncatsService\n member in the same location.\n\n\nConstructor Syntax\n\n\nNest is built around the strong design pattern, which is commonly known as a \nDependency Injection\n. There's a great article about this concept in the \nofficial Angular documentation\n.\n\n\n\n\nHint\n\n\nLearn more about the \nDependency Injection\n in Nest \nhere\n.\n\n\n\n\nIt's extremely easy to manage dependencies with \nTypeScript\n because Nest will recognize your dependencies just by \ntype\n. This single line:\n\n\n1\nconstructor\n(\nprivate\n \nreadonly\n \ncatsService\n: \nCatsService\n)\n \n{}\n`\n\n\n\n\n\n\n\n\n\nWarning\n\n\nBe sure to set the \nemitDecoratorMetadata\n and \nexperimentalDecorators\n flags to true in your tsconfig.json. This tells the compiler to attatch the decorators we use for components to the classes they decorate. Without these flags, you will get a run-time error.\n\n\n\n\nComponent Instantiation\n\n\nThe last thing we need to do is tell the module that \nCatsService\n exists in our codebase. The way to go about notifying Nest of your components is by editing your \napp.module.ts\n file, and putting the service into the \ncomponents\n array of the \n@Module()\n decorator metadata.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nimport\n \n{\n \nModule\n \n}\n \nfrom\n \n@nestjs/common\n;\n\n\nimport\n \n{\n \nCatsController\n \n}\n \nfrom\n \n./cats/cats.controller\n;\n\n\nimport\n \n{\n \nCatsService\n \n}\n \nfrom\n \n./cats/cats.service\n;\n\n\n\n@Module\n({\n\n    \ncontrollers\n:\n \n[\nCatsController\n],\n\n    \ncomponents\n:\n \n[\nCatsService\n],\n\n\n})\n\n\nexport\n \nclass\n \nApplicationModule\n \n{\n \n}\n\n\n\n\n\n\n\nNow Nest will smoothly resolve the dependencies of the \nCatsController\n class.\nThat's how our directories structure looks right now:\n\n\nsrc\n\u2514\u2500\u2500 server.ts\n\u2514\u2500\u2500 modules\n    \u2514\u2500\u2500 app.controller.ts\n    \u2514\u2500\u2500 app.module.ts\n    \u2514\u2500\u2500 cats\n        \u2514\u2500\u2500 cats.service.ts\n        \u2514\u2500\u2500 cats.controller.ts\n        \u2514\u2500\u2500 dto\n            \u2514\u2500\u2500 create-cat.dto.ts\n        \u2514\u2500\u2500 interfaces\n            \u2514\u2500\u2500 cat.interface.ts", 
            "title": "Components"
        }, 
        {
            "location": "/guide/components/#creating-a-component", 
            "text": "Almost everything is a component \u2013 Service, Repository, Factory, Helper [...] and they can be  injected  into controllers or to other components through  constructor .   In the previous chapter, we have built a simple  CatsController .  The controllers should only handle HTTP requests and delegate more complex tasks to the  components . The components are a plain TypeScript classes with  @Component()  decorator.   Hint  Since Nest enables the possibility to design, organize the dependencies in more OO-way, we strongly recommend to follow the  SOLID  principles.   Let's create a  CatsService  component:", 
            "title": "Creating a Component"
        }, 
        {
            "location": "/guide/components/#typescript", 
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15 import   {   Component   }   from   @nestjs/common ;  import   {   Cat   }   from   ./interfaces/cat.interface ;  @Component ()  export   class   CatsService   { \n     private   readonly   cats :  Cat []   =   []; \n\n     create ( cat :  Cat )   { \n         this . cats . push ( cat ); \n     } \n\n     findAll () :   Cat []   { \n         return   this . cats ; \n     }  }", 
            "title": "TypeScript"
        }, 
        {
            "location": "/guide/components/#javascript", 
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 import   {   Component   }   from   @nestjs/common ;  @ Component ()  export   class   CatsService   { \n     constructor ()   { \n         this . cats   =   []; \n     } \n\n     create ( cat )   { \n         this . cats . push ( cat ); \n     } \n\n     findAll ()   { \n         return   this . cats ; \n     }  }    There's nothing specifically about components. Here's a  CatsService , a basic class with one property and two methods. The only difference is that it has the  @Component()  decorator. The  @Component()  attaches the metadata, thereby Nest knows that this class is a Nest component.   Note  There's a  Cat  interface here. I didn't mention it because the schema is exactly same as in the  CreateCatDto  class which we have created in the previous chapter.", 
            "title": "JavaScript"
        }, 
        {
            "location": "/guide/components/#dependency-injection", 
            "text": "Since we have the service class already done, let's use it inside the  CatsController :", 
            "title": "Dependency Injection"
        }, 
        {
            "location": "/guide/components/#typescript_1", 
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19 import   {   Controller ,   Get ,   Post ,   Body   }   from   @nestjs/common ;  import   {   CreateCatDto   }   from   ./dto/create-cat.dto ;  import   {   CatsService   }   from   ./cats.service ;  import   {   Cat   }   from   ./interfaces/cat.interface ;  @Controller ( cats )  export   class   CatsController   { \n     constructor ( private   readonly   catsService :  CatsService )   {} \n\n     @Post () \n     async   create ( @Body ()   createCatDto :  CreateCatDto )   { \n         this . catsService . create ( createCatDto ); \n     } \n\n     @Get () \n     async   findAll () :   Promise Cat []   { \n         return   this . catsService . findAll (); \n     }  }", 
            "title": "TypeScript"
        }, 
        {
            "location": "/guide/components/#javascript_1", 
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21 import   {   Controller ,   Get ,   Post ,   Body ,   Bind ,   Dependencies   }   from   @nestjs/common ;  import   {   CatsService   }   from   ./cats.service ;  @ Controller ( cats )  @ Dependencies ( CatsService )  export   class   CatsController   { \n     constructor ( catsService )   { \n         this . catsService   =   catsService ; \n     } \n\n     @ Post () \n     @ Bind ( Body ()) \n     async   create ( createCatDto )   { \n         this . catsService . create ( createCatDto ); \n     } \n\n     @ Get () \n     async   findAll ()   { \n         return   this . catsService . findAll (); \n     }  }    The  CatsService  is injected through the class constructor. Don't be afraid of the  private readonly  shortened syntax. It means that we've created and initialized the  catsService  member in the same location.", 
            "title": "JavaScript"
        }, 
        {
            "location": "/guide/components/#constructor-syntax", 
            "text": "Nest is built around the strong design pattern, which is commonly known as a  Dependency Injection . There's a great article about this concept in the  official Angular documentation .   Hint  Learn more about the  Dependency Injection  in Nest  here .   It's extremely easy to manage dependencies with  TypeScript  because Nest will recognize your dependencies just by  type . This single line:  1 constructor ( private   readonly   catsService :  CatsService )   {} `     Warning  Be sure to set the  emitDecoratorMetadata  and  experimentalDecorators  flags to true in your tsconfig.json. This tells the compiler to attatch the decorators we use for components to the classes they decorate. Without these flags, you will get a run-time error.", 
            "title": "Constructor Syntax"
        }, 
        {
            "location": "/guide/components/#component-instantiation", 
            "text": "The last thing we need to do is tell the module that  CatsService  exists in our codebase. The way to go about notifying Nest of your components is by editing your  app.module.ts  file, and putting the service into the  components  array of the  @Module()  decorator metadata.  1\n2\n3\n4\n5\n6\n7\n8\n9 import   {   Module   }   from   @nestjs/common ;  import   {   CatsController   }   from   ./cats/cats.controller ;  import   {   CatsService   }   from   ./cats/cats.service ;  @Module ({ \n     controllers :   [ CatsController ], \n     components :   [ CatsService ],  })  export   class   ApplicationModule   {   }    Now Nest will smoothly resolve the dependencies of the  CatsController  class.\nThat's how our directories structure looks right now:  src\n\u2514\u2500\u2500 server.ts\n\u2514\u2500\u2500 modules\n    \u2514\u2500\u2500 app.controller.ts\n    \u2514\u2500\u2500 app.module.ts\n    \u2514\u2500\u2500 cats\n        \u2514\u2500\u2500 cats.service.ts\n        \u2514\u2500\u2500 cats.controller.ts\n        \u2514\u2500\u2500 dto\n            \u2514\u2500\u2500 create-cat.dto.ts\n        \u2514\u2500\u2500 interfaces\n            \u2514\u2500\u2500 cat.interface.ts", 
            "title": "Component Instantiation"
        }
    ]
}