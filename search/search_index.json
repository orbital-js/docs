{
    "docs": [
        {
            "location": "/", 
            "text": "Introduction\n\n\nOrbital is a command-line interface (\nCLI\n) framework used to build scalable command-line programs. Orbital is designed to run on \nNode.JS\n, and uses \nTypeScript\n for type checking and \nmetadata reflection\n. Orbital projects work best when used in conjunction with \nNPM\n, and are distributed as \nNPM\n packages.\n\n\nPhilosophy\n\n\nWhen we began contributing to the Nest CLI project, we found that the framework that was initially used was confusing and non-standard. Upon analyzing other CLI projects, we found that many of them also did not have standards, and were using strange combinations of some of the existing frameworks.\n\n\nWe created Orbital to be the most feature-rich and standardized, yet beautifully simple CLI framework currently available. Out of the box, we've designed Orbital to be the best solution to building your next CLI project.\n\n\nFeatures\n\n\n\n\nBuilt with TypeScript for static type-checking\n\n\nRun-time type checks and parameter casting\n\n\nRun-time validation\n\n\nPerformance-optimized \"production mode\"\n\n\nAngular-based dependency injection\n\n\nBeautiful help generation\n\n\n\n\nInstallation\n\n\nStart a project with \nTypeScript\n:\n\n\n$ git clone https://github.com/orbital-js/starter.git your-project-name\n$ \ncd\n your-project-name\n$ npm install\n$ npm start\n\n\n\n\nStart a new project from scratch with \nNPM\n:\n\n$ npm install --save @orbital/core\n\n\n\nPeople\n\n\nOrbital was created by \nWilson Hobbs\n and \nAnge Picard\n in 2018.\n\n\nContributors", 
            "title": "Home"
        }, 
        {
            "location": "/#introduction", 
            "text": "Orbital is a command-line interface ( CLI ) framework used to build scalable command-line programs. Orbital is designed to run on  Node.JS , and uses  TypeScript  for type checking and  metadata reflection . Orbital projects work best when used in conjunction with  NPM , and are distributed as  NPM  packages.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#philosophy", 
            "text": "When we began contributing to the Nest CLI project, we found that the framework that was initially used was confusing and non-standard. Upon analyzing other CLI projects, we found that many of them also did not have standards, and were using strange combinations of some of the existing frameworks.  We created Orbital to be the most feature-rich and standardized, yet beautifully simple CLI framework currently available. Out of the box, we've designed Orbital to be the best solution to building your next CLI project.", 
            "title": "Philosophy"
        }, 
        {
            "location": "/#features", 
            "text": "Built with TypeScript for static type-checking  Run-time type checks and parameter casting  Run-time validation  Performance-optimized \"production mode\"  Angular-based dependency injection  Beautiful help generation", 
            "title": "Features"
        }, 
        {
            "location": "/#installation", 
            "text": "Start a project with  TypeScript :  $ git clone https://github.com/orbital-js/starter.git your-project-name\n$  cd  your-project-name\n$ npm install\n$ npm start  Start a new project from scratch with  NPM : $ npm install --save @orbital/core", 
            "title": "Installation"
        }, 
        {
            "location": "/#people", 
            "text": "Orbital was created by  Wilson Hobbs  and  Ange Picard  in 2018.", 
            "title": "People"
        }, 
        {
            "location": "/#contributors", 
            "text": "", 
            "title": "Contributors"
        }, 
        {
            "location": "/guide/introduction/", 
            "text": "First Steps\n\n\nIn this set of articles you'll learn the \ncore fundamentals\n of Nest. The main idea is to get familiar with essential Nest application building blocks. You'll build a basic CRUD application which features covers a lot of ground at an introductory level.\n\n\nLanguage\n\n\nWe're in love with \nTypeScript\n, but above all - we love \nNode.JS\n. That's why Nest is compatible with both TypeScript and \npure JavaScript\n. Nest's is taking advantage of latest language features, so to use a framework with simple JavaScript we need a \nBabel\n transpiler.\n\n\nIn the articles, we're mostly using TypeScript, but you can always \nswitch the code snippets\n to the JavaScript version when it contains some TypeScript-specific expressions.\n\n\nPrerequisites\n\n\nPlease make sure that \nNode.JS\n (\n= 6.11.0) is installed on your operating system.\n\n\nSetup\n\n\nSetting up a new project is quite simple with \nstarter repository\n. Just make sure that you have \nNPM\n installed then use following commands in your OS terminal:\n\n\nTypeScript\n\n\n1\n2\n3\ngit clone https://github.com/nestjs/typescript-starter.git project\n\ncd\n project\nnpm install\n\n\n\n\n\n\nJavaScript\n\n\n1\n2\n3\ngit clone https://github.com/nestjs/javascript-starter.git project\n\ncd\n project\nnpm install\n\n\n\n\n\n\nThe \nproject\n directory will contain several core files inside \nsrc\n directory.\n\n\nsrc\n\u2514\u2500\u2500 server.ts\n\u2514\u2500\u2500 modules\n    \u2514\u2500\u2500 app.controller.ts\n    \u2514\u2500\u2500 app.module.ts\n\n\n\n\nFollowing the convention, newly created modules should be placed inside \nmodules\n directory.\n\n\n\n\n\n\n\n\nFile\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nserver.ts\n\n\nThe entry file of the application. It uses \nNestFactory\n to create the Nest application instance.\n\n\n\n\n\n\napp.module.ts\n\n\nDefines \nAppModule\n, the root module of the application.\n\n\n\n\n\n\napp.controller.ts\n\n\nBasic controller example with a single route.\n\n\n\n\n\n\n\n\nThe \nserver.ts\n includes an async function, which responsibility is to \nbootstrap\n our application:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nimport\n \n{\n \nNestFactory\n \n}\n \nfrom\n \n@nestjs/core\n;\n\n\nimport\n \n{\n \nApplicationModule\n \n}\n \nfrom\n \n./modules/app.module\n;\n\n\n\nasync\n \nfunction\n \nbootstrap() {\n\n    \nconst\n \napp\n \n=\n \nawait\n \nNestFactory\n.\ncreate\n(\nApplicationModule\n);\n\n    \nawait\n \napp\n.\nlisten\n(\n3000\n);\n\n\n}\n\n\n\nbootstrap\n();\n\n\n\n\n\n\n\nTo create a Nest application instance, we use the \nNestFactory\n. The \ncreate()\n method returns an object, which implements the \nINestApplication\n interface, and provides a set of usable methods, which are well described in the following guides.\n\n\nRunning Your Application\n\n\nOnce the installation process is completed, you can run the following command to start the HTTP server:\n\n$ npm run start\n\n\nThis command starts the HTTP server on the port defined inside the \nserver.ts\n file in the \nsrc\n directory. While the application is running, open your browser and navigate to \nhttp://localhost:3000/\n. If everything worked correctly, you should see the \nHello world!\n message.", 
            "title": "Introduction"
        }, 
        {
            "location": "/guide/introduction/#first-steps", 
            "text": "In this set of articles you'll learn the  core fundamentals  of Nest. The main idea is to get familiar with essential Nest application building blocks. You'll build a basic CRUD application which features covers a lot of ground at an introductory level.", 
            "title": "First Steps"
        }, 
        {
            "location": "/guide/introduction/#language", 
            "text": "We're in love with  TypeScript , but above all - we love  Node.JS . That's why Nest is compatible with both TypeScript and  pure JavaScript . Nest's is taking advantage of latest language features, so to use a framework with simple JavaScript we need a  Babel  transpiler.  In the articles, we're mostly using TypeScript, but you can always  switch the code snippets  to the JavaScript version when it contains some TypeScript-specific expressions.", 
            "title": "Language"
        }, 
        {
            "location": "/guide/introduction/#prerequisites", 
            "text": "Please make sure that  Node.JS  ( = 6.11.0) is installed on your operating system.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/guide/introduction/#setup", 
            "text": "Setting up a new project is quite simple with  starter repository . Just make sure that you have  NPM  installed then use following commands in your OS terminal:", 
            "title": "Setup"
        }, 
        {
            "location": "/guide/introduction/#typescript", 
            "text": "1\n2\n3 git clone https://github.com/nestjs/typescript-starter.git project cd  project\nnpm install", 
            "title": "TypeScript"
        }, 
        {
            "location": "/guide/introduction/#javascript", 
            "text": "1\n2\n3 git clone https://github.com/nestjs/javascript-starter.git project cd  project\nnpm install   The  project  directory will contain several core files inside  src  directory.  src\n\u2514\u2500\u2500 server.ts\n\u2514\u2500\u2500 modules\n    \u2514\u2500\u2500 app.controller.ts\n    \u2514\u2500\u2500 app.module.ts  Following the convention, newly created modules should be placed inside  modules  directory.     File  Description      server.ts  The entry file of the application. It uses  NestFactory  to create the Nest application instance.    app.module.ts  Defines  AppModule , the root module of the application.    app.controller.ts  Basic controller example with a single route.     The  server.ts  includes an async function, which responsibility is to  bootstrap  our application:  1\n2\n3\n4\n5\n6\n7\n8\n9 import   {   NestFactory   }   from   @nestjs/core ;  import   {   ApplicationModule   }   from   ./modules/app.module ;  async   function   bootstrap() { \n     const   app   =   await   NestFactory . create ( ApplicationModule ); \n     await   app . listen ( 3000 );  }  bootstrap ();    To create a Nest application instance, we use the  NestFactory . The  create()  method returns an object, which implements the  INestApplication  interface, and provides a set of usable methods, which are well described in the following guides.", 
            "title": "JavaScript"
        }, 
        {
            "location": "/guide/introduction/#running-your-application", 
            "text": "Once the installation process is completed, you can run the following command to start the HTTP server: $ npm run start \nThis command starts the HTTP server on the port defined inside the  server.ts  file in the  src  directory. While the application is running, open your browser and navigate to  http://localhost:3000/ . If everything worked correctly, you should see the  Hello world!  message.", 
            "title": "Running Your Application"
        }, 
        {
            "location": "/guide/controllers/", 
            "text": "The controllers layer is responsible for handling incoming \nrequests\n, and return a \nresponse\n to the client.\n\n\n\nTo create a basic controller you have to attach the \nmetadata\n to the class. Thanks to the metadata Nest knows how to map your controller into the appropriate routes. To attach the metadata we're using the \ndecorators\n (in this case \n@Controller(\ncats\n)\n).\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nimport\n \n{\n \nController\n,\n \nGet\n \n}\n \nfrom\n \n@nestjs/common\n;\n\n\n\n@Controller\n(\ncats\n)\n\n\nexport\n \nclass\n \nCatsController\n \n{\n\n    \n@Get\n()\n\n    \nfindAll() {\n\n        \nreturn\n \n[];\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nMetadata\n\n\nWe're using \n@Controller(\ncats\n)\n here. This decorator is \nobligatory\n. The \ncats\n is a prefix for each route registered in the class. The prefix is \noptional\n what means that you could leave the parentheses empty (\n@Controller()\n), but it reduces redundant boilerplate code, thus you don't have to repeat yourself every time when you'd decide to create a new endpoint (route).\n\n\nThere's a single public method, the \nfindAll()\n, which returns an empty array. The \n@Get()\n decorator tells Nest that it's necessary to create an endpoint for this route path and map every appropriate request to this handler. Since we declared the prefix for every route (\ncats\n), Nest will map every \n/cats\n \nGET\n request here.\n\n\nWhen a client would call this endpoint, Nest will return with 200 status code, and the parsed \nJSON\n, so in this case - just an empty array. How is that possible?\n\n\nThere are \ntwo possible approaches\n of manipulating the response:\n\n\n\n\n\n\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nStandard (recommended)\n\n\nWe're treating the handlers in the same way as plain functions. When we return the JavaScript object or array, it'd be \nautomatically\n  transformed to JSON. When we return the string, Nest will send just a string. Furthermore, the response \nstatus code\n is always 200 by default, except POST requests, when it's \n201\n. We can easily change this behavior by adding the \n@HttpCode(...)\n decorator at a handler-level.\n\n\n\n\n\n\nExpress\n\n\nWe can use the express \nresponse\n, which we can inject using \n@Res()\n decorator in the function signature, for example \nfindAll(@Res() response)\n.\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\nIt's forbidden to use both two approaches at the same time. Nest detects whether the handler is using \n@Res()\n or \n@Next()\n, and if it's truth - the standard way is disabled for this single route.\n\n\n\n\nRequest Object\n\n\nA lot of endpoints need an access to the client \nrequest\n details. In fact, Nest is using express \nrequest\n object. We can force Nest to inject the request object into handler using \n@Req()\n decorator.\n\n\n\n\nHint\n\n\nThere's a \n@types/express\n package and we strongly recommend to use it (\nRequest\n has its own typings).\n\n\n\n\nTypeScript\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nimport\n \n{\n \nController\n,\n \nGet\n,\n \nReq\n \n}\n \nfrom\n \n@nestjs/common\n;\n\n\n\n@Controller\n(\ncats\n)\n\n\nexport\n \nclass\n \nCatsController\n \n{\n\n    \n@Get\n()\n\n    \nfindAll\n(\n@Req\n()\n \nrequest\n)\n \n{\n\n        \nreturn\n \n[];\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nJavaScript\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\nimport\n \n{\n \nController\n,\n \nBind\n,\n \nGet\n,\n \nReq\n \n}\n \nfrom\n \n@nestjs/common\n;\n\n\n\n@\nController\n(\ncats\n)\n\n\nexport\n \nclass\n \nCatsController\n \n{\n\n    \n@\nGet\n()\n\n    \n@\nBind\n(\nReq\n())\n\n    \nfindAll\n(\nrequest\n)\n \n{\n\n        \nreturn\n \n[];\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nThe request object represents the HTTP request and has properties for the request query string, parameters, HTTP headers, and e.g. body (read more \nhere\n), but in most cases, it's not necessary to grab them manually.\n We can use \ndedicated decorators\n instead, such as \n@Body()\n or \n@Query()\n, which are available out of the box.\n Below is a comparison of the decorators with the plain express objects.\n\n\n\n\n\n\n\n\nDecorator\n\n\nExpress Equivalent\n\n\n\n\n\n\n\n\n\n\n@Request()\n\n\nreq\n\n\n\n\n\n\n@Response()\n\n\nres\n\n\n\n\n\n\n@Next()\n\n\nnext\n\n\n\n\n\n\n@Session()\n\n\nreq.session\n\n\n\n\n\n\n@Param(param?: string)\n\n\nreq.params\n / \nreq.params[param]\n\n\n\n\n\n\n@Body(param?: string)\n\n\nreq.body\n / \nreq.body[param]\n\n\n\n\n\n\n@Query(param?: string)\n\n\nreq.query\n / \nreq.query[param]\n\n\n\n\n\n\n@Headers(param?: string)\n\n\nreq.headers\n / \nreq.headers[param]\n\n\n\n\n\n\n\n\nMore Endpoints\n\n\nWe have already created an endpoint to fetch the data (\nGET\n route). It'd be great to provide a way of creating the new records too.\n Let's create the \nPOST\n handler:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\nimport\n \n{\n \nController\n,\n \nGet\n,\n \nPost\n \n}\n \nfrom\n \n@nestjs/common\n;\n\n\n\n@Controller\n(\ncats\n)\n\n\nexport\n \nclass\n \nCatsController\n \n{\n\n    \n@Post\n()\n\n    \ncreate() {\n\n        \n// TODO: Add some logic here\n\n    \n}\n\n\n    \n@Get\n()\n\n    \nfindAll() {\n\n        \nreturn\n \n[];\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nIt's really easy. Nest provides the rest of those endpoints decorators in the same fashion - \n@Put()\n, \n@Delete()\n, \n@Patch()\n, \n@Options()\n, \n@Head()\n, and \n@All()\n.\n\n\nStatus Code Manipulation\n\n\nAs mentioned, the response \nstatus code\n is always 200 by default, except POST requests, when it's \n201\n. We can easily change this behavior by adding the \n@HttpCode(...)\n decorator at a handler-level.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\nimport\n \n{\n \nController\n,\n \nGet\n,\n \nPost\n,\n \nHttpStatus\n \n}\n \nfrom\n \n@nestjs/common\n;\n\n\n\n@Controller\n(\ncats\n)\n\n\nexport\n \nclass\n \nCatsController\n \n{\n\n    \n@HttpStatus\n(\n204\n)\n\n    \n@Post\n()\n\n    \ncreate() {\n\n        \n// TODO: Add some logic here\n\n    \n}\n\n\n    \n@Get\n()\n\n    \nfindAll() {\n\n        \nreturn\n \n[];\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nRoute parameters\n\n\nRoutes with static paths can't help when you need to accept \ndynamic data\n as part of the URL.\nTo define routes with route parameters, simply specify the route parameters in the path of the route as shown below.\n\n\n1\n2\n3\n4\n5\n@Get\n(\n:id\n)\n\n\nfindOne\n(\n@Param\n()\n \nparams\n)\n \n{\n\n    \nconsole\n.\nlog\n(\nparams\n.\nid\n);\n\n    \nreturn\n \n{};\n\n\n}\n\n\n\n\n\n\n\nAsync / Await\n\n\nWe love modern JavaScript, and we know that the data extraction is mostly \nasynchronous\n. That's why Nest supports \nasync\n functions, and works pretty well with them.\n\n\n\n\nHint\n\n\nLearn more about \nasync / await\n \nhere\n!\n\n\n\n\nEvery async function has to return the \nPromise\n. It means that you can return deffered value and Nest will resolve it by itself. Let's have a look on the below example:\n\n\nTypeScript\n\n\n1\n2\n3\n4\n@Get\n()\n\n\nasync\n \nfindAll\n()\n:\n \nPromise\nany\n[]\n \n{\n\n    \nreturn\n \n[];\n\n\n}\n\n\n\n\n\n\n\nJavaScript\n\n\n1\n2\n3\n4\n@\nGet\n()\n\n\nasync\n \nfindAll\n()\n \n{\n\n    \nreturn\n \n[];\n\n\n}\n\n\n\n\n\n\n\nObservables\n\n\nFurthermore, Nest route handlers are even more powerful. They can return the RxJS \nobservable streams\n. It makes the migration between a simple web application and the Nest microservice much easier.\n\n\nTypeScript\n\n\n1\n2\n3\n4\n@Get\n()\n\n\nfindAll\n()\n:\n \nObservable\nany\n[]\n \n{\n\n    \nreturn\n \nObservable\n.\nof\n([]);\n\n\n}\n\n\n\n\n\n\n\nJavaScript\n\n\n1\n2\n3\n4\n@\nGet\n()\n\n\nfindAll\n()\n \n{\n\n    \nreturn\n \nObservable\n.\nof\n([]);\n\n\n}\n\n\n\n\n\n\n\nThere is no \"best practice\" in this regard; use whatever format suits your needs.\n\n\nPOST handler\n\n\nThat's strange that this POST route handler doesn't accept any client params. We should at least expect the \n@Body()\n argument here.\n\n\nFirstly, we need to establish the \nDTO\n (Data Transfer Object) schema. A DTO is an object that defines how the data will be sent over the network. We could do it using \nTypeScript\n interfaces, or by simple classes. What may be surprising, we recommend using \nclasses\n here. Why? The classes are the part of the JavaScript ES6 standard, so they're just plain functions. On the other hand, TypeScript interfaces are removed during the transpilation, Nest can't refer to them. It's important because features such as \nPipes\n enables additional possibilities when they've access to the metatype of the variable.\n\n\nLet's create the \nCreateCatDto\n:\n\n\n1\n2\n3\n4\n5\nexport\n \nclass\n \nCreateCatDto\n \n{\n\n    \nreadonly\n \nname\n: \nstring\n;\n\n    \nreadonly\n \nage\n: \nnumber\n;\n\n    \nreadonly\n \nbreed\n: \nstring\n;\n\n\n}\n\n\n\n\n\n\n\nIt has only three basic properties. All of them are marked as a \nreadonly\n, because we should always try to make our functions as \npure\n as possible.\n\n\nNow we can use the schema inside the \nCatsController\n:\n\n\nTypeScript\n\n\n1\n2\n3\n4\n@Post\n()\n\n\nasync\n \ncreate\n(\n@Body\n()\n \ncreateCatDto\n: \nCreateCatDto\n)\n \n{\n\n    \n// TODO: Add some logic here\n\n\n}\n\n\n\n\n\n\n\nJavaScript\n\n\n1\n2\n3\n4\n5\n@\nPost\n()\n\n\n@\nBind\n(\nBody\n())\n\n\nasync\n \ncreate\n(\ncreateCatDto\n)\n \n{\n\n    \n// TODO: Add some logic here\n\n\n}\n\n\n\n\n\n\n\nError Handling\n\n\n\nThere's a separated chapter about working with the exceptions \nhere\n.\n\n\nLast Step\n\n\nThe controller is prepared, and ready to use, but Nest doesn't know that \nCatsController\n exists yet, so it won't create an instance of this class. We need to tell about it.\n\n\nThe controller always belongs to the module, that's why we hold \ncontrollers\n array within \n@Module()\n decorator. Since we don't have any other modules except the root \nApplicationModule\n, let's use it for now:\n\n\n1\n2\n3\n4\n5\n6\n7\nimport\n \n{\n \nModule\n \n}\n \nfrom\n \n@nestjs/common\n;\n\n\nimport\n \n{\n \nCatsController\n \n}\n \nfrom\n \n./cats/cats.controller\n;\n\n\n\n@Module\n({\n\n    \ncontrollers\n:\n \n[\nCatsController\n],\n\n\n})\n\n\nexport\n \nclass\n \nApplicationModule\n \n{\n \n}\n\n\n\n\n\n\n\nTada! We attached the metadata to the module class, so now Nest can easily reflect which controllers have to be mounted.\n\n\nExpress Approach\n\n\nThe second way of manipulating the response is to use express \nresponse\n object. It was the only available option until \nNest 4\n. To inject the response object, we need to use \n@Res()\n decorator. To show the differences, i'm going to rewrite the \nCatsController\n:\n\n\nTypeScript\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\nimport\n \n{\n \nController\n,\n \nGet\n,\n \nPost\n,\n \nRes\n,\n \nBody\n,\n \nHttpStatus\n \n}\n \nfrom\n \n@nestjs/common\n;\n\n\nimport\n \n{\n \nCreateCatDto\n \n}\n \nfrom\n \n./dto/create-cat.dto\n;\n\n\n\n@Controller\n(\ncats\n)\n\n\nexport\n \nclass\n \nCatsController\n \n{\n\n    \n@Post\n()\n\n    \ncreate\n(\n@Res\n()\n \nres\n,\n \n@Body\n()\n \ncreateCatDto\n: \nCreateCatDto\n)\n \n{\n\n        \n// TODO: Add some logic here\n\n        \nres\n.\nstatus\n(\nHttpStatus\n.\nCREATED\n).\nsend\n();\n\n    \n}\n\n\n    \n@Get\n()\n\n    \nfindAll\n(\n@Res\n()\n \nres\n)\n \n{\n\n        \nres\n.\nstatus\n(\nHttpStatus\n.\nOK\n).\njson\n([]);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nJavaScript\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\nimport\n \n{\n \nController\n,\n \nGet\n,\n \nPost\n,\n \nBind\n,\n \nRes\n,\n \nBody\n,\n \nHttpStatus\n \n}\n \nfrom\n \n@nestjs/common\n;\n\n\n\n@\nController\n(\ncats\n)\n\n\nexport\n \nclass\n \nCatsController\n \n{\n\n    \n@\nPost\n()\n\n    \n@\nBind\n(\nRes\n(),\n \nBody\n())\n\n    \ncreate\n(\nres\n,\n \ncreateCatDto\n)\n \n{\n\n        \n// TODO: Add some logic here\n\n        \nres\n.\nstatus\n(\nHttpStatus\n.\nCREATED\n).\nsend\n();\n\n    \n}\n\n\n    \n@\nGet\n()\n\n    \n@\nBind\n(\nRes\n())\n\n    \nfindAll\n(\nres\n)\n \n{\n\n        \nres\n.\nstatus\n(\nHttpStatus\n.\nOK\n).\njson\n([]);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nThis manner is much less clear from my point of view. I definitely prefer the first approach, but to make the Nest \nbackward compatible\n with the previous versions, this method is still available. Also, the \nresponse object\n gives more flexibility - you've full control of the response.", 
            "title": "Controllers"
        }, 
        {
            "location": "/guide/controllers/#metadata", 
            "text": "We're using  @Controller( cats )  here. This decorator is  obligatory . The  cats  is a prefix for each route registered in the class. The prefix is  optional  what means that you could leave the parentheses empty ( @Controller() ), but it reduces redundant boilerplate code, thus you don't have to repeat yourself every time when you'd decide to create a new endpoint (route).  There's a single public method, the  findAll() , which returns an empty array. The  @Get()  decorator tells Nest that it's necessary to create an endpoint for this route path and map every appropriate request to this handler. Since we declared the prefix for every route ( cats ), Nest will map every  /cats   GET  request here.  When a client would call this endpoint, Nest will return with 200 status code, and the parsed  JSON , so in this case - just an empty array. How is that possible?  There are  two possible approaches  of manipulating the response:     Method  Description      Standard (recommended)  We're treating the handlers in the same way as plain functions. When we return the JavaScript object or array, it'd be  automatically   transformed to JSON. When we return the string, Nest will send just a string. Furthermore, the response  status code  is always 200 by default, except POST requests, when it's  201 . We can easily change this behavior by adding the  @HttpCode(...)  decorator at a handler-level.    Express  We can use the express  response , which we can inject using  @Res()  decorator in the function signature, for example  findAll(@Res() response) .      Warning  It's forbidden to use both two approaches at the same time. Nest detects whether the handler is using  @Res()  or  @Next() , and if it's truth - the standard way is disabled for this single route.", 
            "title": "Metadata"
        }, 
        {
            "location": "/guide/controllers/#request-object", 
            "text": "A lot of endpoints need an access to the client  request  details. In fact, Nest is using express  request  object. We can force Nest to inject the request object into handler using  @Req()  decorator.   Hint  There's a  @types/express  package and we strongly recommend to use it ( Request  has its own typings).", 
            "title": "Request Object"
        }, 
        {
            "location": "/guide/controllers/#typescript", 
            "text": "1\n2\n3\n4\n5\n6\n7\n8\n9 import   {   Controller ,   Get ,   Req   }   from   @nestjs/common ;  @Controller ( cats )  export   class   CatsController   { \n     @Get () \n     findAll ( @Req ()   request )   { \n         return   []; \n     }  }", 
            "title": "TypeScript"
        }, 
        {
            "location": "/guide/controllers/#javascript", 
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 import   {   Controller ,   Bind ,   Get ,   Req   }   from   @nestjs/common ;  @ Controller ( cats )  export   class   CatsController   { \n     @ Get () \n     @ Bind ( Req ()) \n     findAll ( request )   { \n         return   []; \n     }  }    The request object represents the HTTP request and has properties for the request query string, parameters, HTTP headers, and e.g. body (read more  here ), but in most cases, it's not necessary to grab them manually.\n We can use  dedicated decorators  instead, such as  @Body()  or  @Query() , which are available out of the box.\n Below is a comparison of the decorators with the plain express objects.     Decorator  Express Equivalent      @Request()  req    @Response()  res    @Next()  next    @Session()  req.session    @Param(param?: string)  req.params  /  req.params[param]    @Body(param?: string)  req.body  /  req.body[param]    @Query(param?: string)  req.query  /  req.query[param]    @Headers(param?: string)  req.headers  /  req.headers[param]", 
            "title": "JavaScript"
        }, 
        {
            "location": "/guide/controllers/#more-endpoints", 
            "text": "We have already created an endpoint to fetch the data ( GET  route). It'd be great to provide a way of creating the new records too.\n Let's create the  POST  handler:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 import   {   Controller ,   Get ,   Post   }   from   @nestjs/common ;  @Controller ( cats )  export   class   CatsController   { \n     @Post () \n     create() { \n         // TODO: Add some logic here \n     } \n\n     @Get () \n     findAll() { \n         return   []; \n     }  }    It's really easy. Nest provides the rest of those endpoints decorators in the same fashion -  @Put() ,  @Delete() ,  @Patch() ,  @Options() ,  @Head() , and  @All() .", 
            "title": "More Endpoints"
        }, 
        {
            "location": "/guide/controllers/#status-code-manipulation", 
            "text": "As mentioned, the response  status code  is always 200 by default, except POST requests, when it's  201 . We can easily change this behavior by adding the  @HttpCode(...)  decorator at a handler-level.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15 import   {   Controller ,   Get ,   Post ,   HttpStatus   }   from   @nestjs/common ;  @Controller ( cats )  export   class   CatsController   { \n     @HttpStatus ( 204 ) \n     @Post () \n     create() { \n         // TODO: Add some logic here \n     } \n\n     @Get () \n     findAll() { \n         return   []; \n     }  }", 
            "title": "Status Code Manipulation"
        }, 
        {
            "location": "/guide/controllers/#route-parameters", 
            "text": "Routes with static paths can't help when you need to accept  dynamic data  as part of the URL.\nTo define routes with route parameters, simply specify the route parameters in the path of the route as shown below.  1\n2\n3\n4\n5 @Get ( :id )  findOne ( @Param ()   params )   { \n     console . log ( params . id ); \n     return   {};  }", 
            "title": "Route parameters"
        }, 
        {
            "location": "/guide/controllers/#async-await", 
            "text": "We love modern JavaScript, and we know that the data extraction is mostly  asynchronous . That's why Nest supports  async  functions, and works pretty well with them.   Hint  Learn more about  async / await   here !   Every async function has to return the  Promise . It means that you can return deffered value and Nest will resolve it by itself. Let's have a look on the below example:", 
            "title": "Async / Await"
        }, 
        {
            "location": "/guide/controllers/#typescript_1", 
            "text": "1\n2\n3\n4 @Get ()  async   findAll () :   Promise any []   { \n     return   [];  }", 
            "title": "TypeScript"
        }, 
        {
            "location": "/guide/controllers/#javascript_1", 
            "text": "1\n2\n3\n4 @ Get ()  async   findAll ()   { \n     return   [];  }", 
            "title": "JavaScript"
        }, 
        {
            "location": "/guide/controllers/#observables", 
            "text": "Furthermore, Nest route handlers are even more powerful. They can return the RxJS  observable streams . It makes the migration between a simple web application and the Nest microservice much easier.", 
            "title": "Observables"
        }, 
        {
            "location": "/guide/controllers/#typescript_2", 
            "text": "1\n2\n3\n4 @Get ()  findAll () :   Observable any []   { \n     return   Observable . of ([]);  }", 
            "title": "TypeScript"
        }, 
        {
            "location": "/guide/controllers/#javascript_2", 
            "text": "1\n2\n3\n4 @ Get ()  findAll ()   { \n     return   Observable . of ([]);  }    There is no \"best practice\" in this regard; use whatever format suits your needs.", 
            "title": "JavaScript"
        }, 
        {
            "location": "/guide/controllers/#post-handler", 
            "text": "That's strange that this POST route handler doesn't accept any client params. We should at least expect the  @Body()  argument here.  Firstly, we need to establish the  DTO  (Data Transfer Object) schema. A DTO is an object that defines how the data will be sent over the network. We could do it using  TypeScript  interfaces, or by simple classes. What may be surprising, we recommend using  classes  here. Why? The classes are the part of the JavaScript ES6 standard, so they're just plain functions. On the other hand, TypeScript interfaces are removed during the transpilation, Nest can't refer to them. It's important because features such as  Pipes  enables additional possibilities when they've access to the metatype of the variable.  Let's create the  CreateCatDto :  1\n2\n3\n4\n5 export   class   CreateCatDto   { \n     readonly   name :  string ; \n     readonly   age :  number ; \n     readonly   breed :  string ;  }    It has only three basic properties. All of them are marked as a  readonly , because we should always try to make our functions as  pure  as possible.  Now we can use the schema inside the  CatsController :", 
            "title": "POST handler"
        }, 
        {
            "location": "/guide/controllers/#typescript_3", 
            "text": "1\n2\n3\n4 @Post ()  async   create ( @Body ()   createCatDto :  CreateCatDto )   { \n     // TODO: Add some logic here  }", 
            "title": "TypeScript"
        }, 
        {
            "location": "/guide/controllers/#javascript_3", 
            "text": "1\n2\n3\n4\n5 @ Post ()  @ Bind ( Body ())  async   create ( createCatDto )   { \n     // TODO: Add some logic here  }", 
            "title": "JavaScript"
        }, 
        {
            "location": "/guide/controllers/#error-handling", 
            "text": "There's a separated chapter about working with the exceptions  here .", 
            "title": "Error Handling"
        }, 
        {
            "location": "/guide/controllers/#last-step", 
            "text": "The controller is prepared, and ready to use, but Nest doesn't know that  CatsController  exists yet, so it won't create an instance of this class. We need to tell about it.  The controller always belongs to the module, that's why we hold  controllers  array within  @Module()  decorator. Since we don't have any other modules except the root  ApplicationModule , let's use it for now:  1\n2\n3\n4\n5\n6\n7 import   {   Module   }   from   @nestjs/common ;  import   {   CatsController   }   from   ./cats/cats.controller ;  @Module ({ \n     controllers :   [ CatsController ],  })  export   class   ApplicationModule   {   }    Tada! We attached the metadata to the module class, so now Nest can easily reflect which controllers have to be mounted.", 
            "title": "Last Step"
        }, 
        {
            "location": "/guide/controllers/#express-approach", 
            "text": "The second way of manipulating the response is to use express  response  object. It was the only available option until  Nest 4 . To inject the response object, we need to use  @Res()  decorator. To show the differences, i'm going to rewrite the  CatsController :", 
            "title": "Express Approach"
        }, 
        {
            "location": "/guide/controllers/#typescript_4", 
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 import   {   Controller ,   Get ,   Post ,   Res ,   Body ,   HttpStatus   }   from   @nestjs/common ;  import   {   CreateCatDto   }   from   ./dto/create-cat.dto ;  @Controller ( cats )  export   class   CatsController   { \n     @Post () \n     create ( @Res ()   res ,   @Body ()   createCatDto :  CreateCatDto )   { \n         // TODO: Add some logic here \n         res . status ( HttpStatus . CREATED ). send (); \n     } \n\n     @Get () \n     findAll ( @Res ()   res )   { \n         res . status ( HttpStatus . OK ). json ([]); \n     }  }", 
            "title": "TypeScript"
        }, 
        {
            "location": "/guide/controllers/#javascript_4", 
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17 import   {   Controller ,   Get ,   Post ,   Bind ,   Res ,   Body ,   HttpStatus   }   from   @nestjs/common ;  @ Controller ( cats )  export   class   CatsController   { \n     @ Post () \n     @ Bind ( Res (),   Body ()) \n     create ( res ,   createCatDto )   { \n         // TODO: Add some logic here \n         res . status ( HttpStatus . CREATED ). send (); \n     } \n\n     @ Get () \n     @ Bind ( Res ()) \n     findAll ( res )   { \n         res . status ( HttpStatus . OK ). json ([]); \n     }  }    This manner is much less clear from my point of view. I definitely prefer the first approach, but to make the Nest  backward compatible  with the previous versions, this method is still available. Also, the  response object  gives more flexibility - you've full control of the response.", 
            "title": "JavaScript"
        }, 
        {
            "location": "/guide/components/", 
            "text": "Creating a Component\n\n\nAlmost everything is a component \u2013 Service, Repository, Factory, Helper [...] and they can be \ninjected\n into controllers or to other components through \nconstructor\n.\n\n\n\n\nIn the previous chapter, we have built a simple \nCatsController\n.\n\n\nThe controllers should only handle HTTP requests and delegate more complex tasks to the \ncomponents\n. The components are a plain TypeScript classes with \n@Component()\n decorator.\n\n\n\n\nHint\n\n\nSince Nest enables the possibility to design, organize the dependencies in more OO-way, we strongly recommend to follow the \nSOLID\n principles.\n\n\n\n\nLet's create a \nCatsService\n component:\n\n\nTypeScript\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\nimport\n \n{\n \nComponent\n \n}\n \nfrom\n \n@nestjs/common\n;\n\n\nimport\n \n{\n \nCat\n \n}\n \nfrom\n \n./interfaces/cat.interface\n;\n\n\n\n@Component\n()\n\n\nexport\n \nclass\n \nCatsService\n \n{\n\n    \nprivate\n \nreadonly\n \ncats\n: \nCat\n[]\n \n=\n \n[];\n\n\n    \ncreate\n(\ncat\n: \nCat\n)\n \n{\n\n        \nthis\n.\ncats\n.\npush\n(\ncat\n);\n\n    \n}\n\n\n    \nfindAll\n()\n:\n \nCat\n[]\n \n{\n\n        \nreturn\n \nthis\n.\ncats\n;\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nJavaScript\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\nimport\n \n{\n \nComponent\n \n}\n \nfrom\n \n@nestjs/common\n;\n\n\n\n@\nComponent\n()\n\n\nexport\n \nclass\n \nCatsService\n \n{\n\n    \nconstructor\n()\n \n{\n\n        \nthis\n.\ncats\n \n=\n \n[];\n\n    \n}\n\n\n    \ncreate\n(\ncat\n)\n \n{\n\n        \nthis\n.\ncats\n.\npush\n(\ncat\n);\n\n    \n}\n\n\n    \nfindAll\n()\n \n{\n\n        \nreturn\n \nthis\n.\ncats\n;\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nThere's nothing specifically about components. Here's a \nCatsService\n, a basic class with one property and two methods. The only difference is that it has the \n@Component()\n decorator. The \n@Component()\n attaches the metadata, thereby Nest knows that this class is a Nest component.\n\n\n\n\nNote\n\n\nThere's a \nCat\n interface here. I didn't mention it because the schema is exactly same as in the \nCreateCatDto\n class which we have created in the previous chapter.\n\n\n\n\nDependency Injection\n\n\nSince we have the service class already done, let's use it inside the \nCatsController\n:\n\n\nTypeScript\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nimport\n \n{\n \nController\n,\n \nGet\n,\n \nPost\n,\n \nBody\n \n}\n \nfrom\n \n@nestjs/common\n;\n\n\nimport\n \n{\n \nCreateCatDto\n \n}\n \nfrom\n \n./dto/create-cat.dto\n;\n\n\nimport\n \n{\n \nCatsService\n \n}\n \nfrom\n \n./cats.service\n;\n\n\nimport\n \n{\n \nCat\n \n}\n \nfrom\n \n./interfaces/cat.interface\n;\n\n\n\n@Controller\n(\ncats\n)\n\n\nexport\n \nclass\n \nCatsController\n \n{\n\n    \nconstructor\n(\nprivate\n \nreadonly\n \ncatsService\n: \nCatsService\n)\n \n{}\n\n\n    \n@Post\n()\n\n    \nasync\n \ncreate\n(\n@Body\n()\n \ncreateCatDto\n: \nCreateCatDto\n)\n \n{\n\n        \nthis\n.\ncatsService\n.\ncreate\n(\ncreateCatDto\n);\n\n    \n}\n\n\n    \n@Get\n()\n\n    \nasync\n \nfindAll\n()\n:\n \nPromise\nCat\n[]\n \n{\n\n        \nreturn\n \nthis\n.\ncatsService\n.\nfindAll\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nJavaScript\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nimport\n \n{\n \nController\n,\n \nGet\n,\n \nPost\n,\n \nBody\n,\n \nBind\n,\n \nDependencies\n \n}\n \nfrom\n \n@nestjs/common\n;\n\n\nimport\n \n{\n \nCatsService\n \n}\n \nfrom\n \n./cats.service\n;\n\n\n\n@\nController\n(\ncats\n)\n\n\n@\nDependencies\n(\nCatsService\n)\n\n\nexport\n \nclass\n \nCatsController\n \n{\n\n    \nconstructor\n(\ncatsService\n)\n \n{\n\n        \nthis\n.\ncatsService\n \n=\n \ncatsService\n;\n\n    \n}\n\n\n    \n@\nPost\n()\n\n    \n@\nBind\n(\nBody\n())\n\n    \nasync\n \ncreate\n(\ncreateCatDto\n)\n \n{\n\n        \nthis\n.\ncatsService\n.\ncreate\n(\ncreateCatDto\n);\n\n    \n}\n\n\n    \n@\nGet\n()\n\n    \nasync\n \nfindAll\n()\n \n{\n\n        \nreturn\n \nthis\n.\ncatsService\n.\nfindAll\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nThe \nCatsService\n is injected through the class constructor. Don't be afraid of the \nprivate readonly\n shortened syntax. It means that we've created and initialized the \ncatsService\n member in the same location.\n\n\nConstructor Syntax\n\n\nNest is built around the strong design pattern, which is commonly known as a \nDependency Injection\n. There's a great article about this concept in the \nofficial Angular documentation\n.\n\n\n\n\nHint\n\n\nLearn more about the \nDependency Injection\n in Nest \nhere\n.\n\n\n\n\nIt's extremely easy to manage dependencies with \nTypeScript\n because Nest will recognize your dependencies just by \ntype\n. This single line:\n\n\n1\nconstructor\n(\nprivate\n \nreadonly\n \ncatsService\n: \nCatsService\n)\n \n{}\n`\n\n\n\n\n\n\n\n\n\nWarning\n\n\nBe sure to set the \nemitDecoratorMetadata\n and \nexperimentalDecorators\n flags to true in your tsconfig.json. This tells the compiler to attatch the decorators we use for components to the classes they decorate. Without these flags, you will get a run-time error.\n\n\n\n\nComponent Instantiation\n\n\nThe last thing we need to do is tell the module that \nCatsService\n exists in our codebase. The way to go about notifying Nest of your components is by editing your \napp.module.ts\n file, and putting the service into the \ncomponents\n array of the \n@Module()\n decorator metadata.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nimport\n \n{\n \nModule\n \n}\n \nfrom\n \n@nestjs/common\n;\n\n\nimport\n \n{\n \nCatsController\n \n}\n \nfrom\n \n./cats/cats.controller\n;\n\n\nimport\n \n{\n \nCatsService\n \n}\n \nfrom\n \n./cats/cats.service\n;\n\n\n\n@Module\n({\n\n    \ncontrollers\n:\n \n[\nCatsController\n],\n\n    \ncomponents\n:\n \n[\nCatsService\n],\n\n\n})\n\n\nexport\n \nclass\n \nApplicationModule\n \n{\n \n}\n\n\n\n\n\n\n\nNow Nest will smoothly resolve the dependencies of the \nCatsController\n class.\nThat's how our directories structure looks right now:\n\n\nsrc\n\u2514\u2500\u2500 server.ts\n\u2514\u2500\u2500 modules\n    \u2514\u2500\u2500 app.controller.ts\n    \u2514\u2500\u2500 app.module.ts\n    \u2514\u2500\u2500 cats\n        \u2514\u2500\u2500 cats.service.ts\n        \u2514\u2500\u2500 cats.controller.ts\n        \u2514\u2500\u2500 dto\n            \u2514\u2500\u2500 create-cat.dto.ts\n        \u2514\u2500\u2500 interfaces\n            \u2514\u2500\u2500 cat.interface.ts", 
            "title": "Components"
        }, 
        {
            "location": "/guide/components/#creating-a-component", 
            "text": "Almost everything is a component \u2013 Service, Repository, Factory, Helper [...] and they can be  injected  into controllers or to other components through  constructor .   In the previous chapter, we have built a simple  CatsController .  The controllers should only handle HTTP requests and delegate more complex tasks to the  components . The components are a plain TypeScript classes with  @Component()  decorator.   Hint  Since Nest enables the possibility to design, organize the dependencies in more OO-way, we strongly recommend to follow the  SOLID  principles.   Let's create a  CatsService  component:", 
            "title": "Creating a Component"
        }, 
        {
            "location": "/guide/components/#typescript", 
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15 import   {   Component   }   from   @nestjs/common ;  import   {   Cat   }   from   ./interfaces/cat.interface ;  @Component ()  export   class   CatsService   { \n     private   readonly   cats :  Cat []   =   []; \n\n     create ( cat :  Cat )   { \n         this . cats . push ( cat ); \n     } \n\n     findAll () :   Cat []   { \n         return   this . cats ; \n     }  }", 
            "title": "TypeScript"
        }, 
        {
            "location": "/guide/components/#javascript", 
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 import   {   Component   }   from   @nestjs/common ;  @ Component ()  export   class   CatsService   { \n     constructor ()   { \n         this . cats   =   []; \n     } \n\n     create ( cat )   { \n         this . cats . push ( cat ); \n     } \n\n     findAll ()   { \n         return   this . cats ; \n     }  }    There's nothing specifically about components. Here's a  CatsService , a basic class with one property and two methods. The only difference is that it has the  @Component()  decorator. The  @Component()  attaches the metadata, thereby Nest knows that this class is a Nest component.   Note  There's a  Cat  interface here. I didn't mention it because the schema is exactly same as in the  CreateCatDto  class which we have created in the previous chapter.", 
            "title": "JavaScript"
        }, 
        {
            "location": "/guide/components/#dependency-injection", 
            "text": "Since we have the service class already done, let's use it inside the  CatsController :", 
            "title": "Dependency Injection"
        }, 
        {
            "location": "/guide/components/#typescript_1", 
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19 import   {   Controller ,   Get ,   Post ,   Body   }   from   @nestjs/common ;  import   {   CreateCatDto   }   from   ./dto/create-cat.dto ;  import   {   CatsService   }   from   ./cats.service ;  import   {   Cat   }   from   ./interfaces/cat.interface ;  @Controller ( cats )  export   class   CatsController   { \n     constructor ( private   readonly   catsService :  CatsService )   {} \n\n     @Post () \n     async   create ( @Body ()   createCatDto :  CreateCatDto )   { \n         this . catsService . create ( createCatDto ); \n     } \n\n     @Get () \n     async   findAll () :   Promise Cat []   { \n         return   this . catsService . findAll (); \n     }  }", 
            "title": "TypeScript"
        }, 
        {
            "location": "/guide/components/#javascript_1", 
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21 import   {   Controller ,   Get ,   Post ,   Body ,   Bind ,   Dependencies   }   from   @nestjs/common ;  import   {   CatsService   }   from   ./cats.service ;  @ Controller ( cats )  @ Dependencies ( CatsService )  export   class   CatsController   { \n     constructor ( catsService )   { \n         this . catsService   =   catsService ; \n     } \n\n     @ Post () \n     @ Bind ( Body ()) \n     async   create ( createCatDto )   { \n         this . catsService . create ( createCatDto ); \n     } \n\n     @ Get () \n     async   findAll ()   { \n         return   this . catsService . findAll (); \n     }  }    The  CatsService  is injected through the class constructor. Don't be afraid of the  private readonly  shortened syntax. It means that we've created and initialized the  catsService  member in the same location.", 
            "title": "JavaScript"
        }, 
        {
            "location": "/guide/components/#constructor-syntax", 
            "text": "Nest is built around the strong design pattern, which is commonly known as a  Dependency Injection . There's a great article about this concept in the  official Angular documentation .   Hint  Learn more about the  Dependency Injection  in Nest  here .   It's extremely easy to manage dependencies with  TypeScript  because Nest will recognize your dependencies just by  type . This single line:  1 constructor ( private   readonly   catsService :  CatsService )   {} `     Warning  Be sure to set the  emitDecoratorMetadata  and  experimentalDecorators  flags to true in your tsconfig.json. This tells the compiler to attatch the decorators we use for components to the classes they decorate. Without these flags, you will get a run-time error.", 
            "title": "Constructor Syntax"
        }, 
        {
            "location": "/guide/components/#component-instantiation", 
            "text": "The last thing we need to do is tell the module that  CatsService  exists in our codebase. The way to go about notifying Nest of your components is by editing your  app.module.ts  file, and putting the service into the  components  array of the  @Module()  decorator metadata.  1\n2\n3\n4\n5\n6\n7\n8\n9 import   {   Module   }   from   @nestjs/common ;  import   {   CatsController   }   from   ./cats/cats.controller ;  import   {   CatsService   }   from   ./cats/cats.service ;  @Module ({ \n     controllers :   [ CatsController ], \n     components :   [ CatsService ],  })  export   class   ApplicationModule   {   }    Now Nest will smoothly resolve the dependencies of the  CatsController  class.\nThat's how our directories structure looks right now:  src\n\u2514\u2500\u2500 server.ts\n\u2514\u2500\u2500 modules\n    \u2514\u2500\u2500 app.controller.ts\n    \u2514\u2500\u2500 app.module.ts\n    \u2514\u2500\u2500 cats\n        \u2514\u2500\u2500 cats.service.ts\n        \u2514\u2500\u2500 cats.controller.ts\n        \u2514\u2500\u2500 dto\n            \u2514\u2500\u2500 create-cat.dto.ts\n        \u2514\u2500\u2500 interfaces\n            \u2514\u2500\u2500 cat.interface.ts", 
            "title": "Component Instantiation"
        }
    ]
}